<!DOCTYPE html>

<html>
    <head>
        <title>The STEM Zone</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@200;300&display=swap" rel="stylesheet">
        <link href="../../formatting.css" rel="stylesheet">
        <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico"/>

        <script src="../../p5.js library/p5.js"></script>
        <script src="../../p5.js library/p5.sound.js"></script>

        <script src="BubbleSort.js"></script>
    </head>

    <body>

        <div class="titlebar">
            <img src="../../sort.png" width="100" height ="100" style="padding:10px 30px 0px 10px; float:left;"/>
            <h1>Sorting Algorithms</h1>
            <p>Marvel at the elegance of bogosort</p>
        </div>

        <a href="../../index.html">HOME</a>
        <h1 style="text-align: center;"> Bubble Sort</h1>

        <div id="simulation" style="height: 400px;"> 

        </div>

        <div class="explanation">
            <p> 
                Bubble sort is by far one of the most simple sorting algorithms to be exposed to. The plan is simple, compare every element to its element to the right. 
                If the first element is greater, the two elements swap. Once all of the elements are compared, this process is repeated again. The name of 
                this sort is bubble sort since this has the effect of bringing the greatest element to the end of the list. Since each pass through the array puts the greatest 
                element to the end of the list, one less element needs to be checked each pass. The final optimization that could be made is to end the sort if it finishes a 
                complete pass without making any swaps (since that means all elements are in order).
            </p>

            <p> 
                This algorithm takes very little code and is easy to understand, but ultimately it is incredibly inefficient. The next page will talk about Big-O 
                Notation, and using that system this algorithm has an average complexity of O(n^2). The psuedo-code listed below demonstrates a possible 
                implementation of this algorithm.
            </p>
        </div>

        <pre>
            <code>
    procedure sort(unsorted_array) {

        // this outer loop runs until the array is sorted
        for (i = 1, i < unsorted_array.size - 1 ) {

            // the number of swaps is recorded in case the list is already sorted
            number_swaps = 0

            // each passing of this loop brings the greatest element to the end of the list
            for (j = 0, j < unsorted_array.size - i) {
                
                // is this pair of elements sorted? if not swap them.
                if unsorted_array[j+1] < unsorted_array[j] {
                    temp_val = unsorted_array[j]
                    unsorted_array[j] = unsorted_array[j+1]
                    unsorted_array[j+1] = temp_val

                    number_swaps++
                }
            }    

            // stop looping if the sort is completed
            if (number_swaps == 0) { 
                break
            }
        }      
    }
            </code>
        </pre>

        <h1 style="text-align: center;"> Selection and Insertion Sort</h1>

        <div class="explanation">
            <p> 
            Selection Sort and Insertion Sort are the next two easiest sorting algorithms to understand. First, let's talk about Selection Sort. The sort starts by creating a 
            variable which stores the first value in the unsorted array. This element is compared one by one with all other elements in the unsorted part of the array. If a smaller 
            number is found, that value is stored in the variable. Once the entire array is searched, this minimum value is swapped with the first value in the unsorted array. This 
            value is then considered sorted and ignored for the next pass in the sort. This process is repeated until all values are sorted.
            </p>

            <p>
            Summarized, this sort essentially finds the correct value for each position in the array and puts it there one by one.
            </p>

            <p>
            Next let's talk about Insertion Sort. Insertion sort first considers the initial value in an array as sorted. The sort then looks at the first unsorted value in the 
            array and compares it to the values in the sorted segment of the array. Once it finds the first value greater than the selected element, it pushes all values after this 
            position one index forward and places the selected value into its correct place. Once all values in the unsorted array have been repositioned, this sort is completed.
            </p>

            <p>
            Summarized, this sort essentially splits the array into a sorted and unsorted section and one by one puts the first unsorted element into the correct spot.
            </p>

            <p> 
            These sorts are fairly similar in their methodology, so a diagram demonstrating how this sort performs will be shown below. Like BubbleSort, these sorts still 
            are incredibly inefficient with an average time complexity of O(n^2). The next two sections will go more in detail about faster sorts for larger amounts of data.
            </p>
        </div>

        <img src="Demonstration.png" alt="Left shows selection where red numbers are swapped. Right shows insertion where green letters are sorted" style="margin-left: auto; margin-right: auto; display: block;">
       
        <div class="explanation">
            <p> 
                On the next page, we will discuss how quicksort works.
            </p>
        </div>

        <p> <a href="IntroGame.html">Last Page</a> <a href="QuickSort.html">Next Page</a> </p>
    </body>
</html>